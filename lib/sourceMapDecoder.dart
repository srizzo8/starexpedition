import 'dart:convert';
import 'dart:typed_data';
import 'package:http/http.dart' as http;

//This class is a decoded mapping:
class decodedMapping{
  final int myGeneratedLine;
  final int myGeneratedColumn;
  final int mySourceIndex;
  final int mySourceLine;
  final int mySourceColumn;

  decodedMapping(this.myGeneratedLine, this.myGeneratedColumn, this.mySourceIndex, this.mySourceLine, this.mySourceColumn);
}

//This class decodes a base64 VLQ segment:
class myVlqDecoder{
  static const int VLQ_BASE_SHIFT = 5;
  static const int VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  static const int VLQ_BASE_MASK = VLQ_BASE - 1;
  static const int VLQ_CONTINUATION_BIT = VLQ_BASE;

  static int fromVlqSigned(int myValue){
    bool isNegative = (myValue & 1) == 1;
    int shift = myValue >> 1;
    return isNegative ? -shift : shift;
  }

  static List<int> decoding(String myString){
    List<int> myResult = [];
    int myIndex = 0;
    int myValue = 0;
    int myShift = 0;

    while(myIndex < myString.length){
      int myCharCode = convertingCharToValue(myString.codeUnitAt(myIndex));
      myIndex++;

      bool hasContinuation = (myCharCode & VLQ_CONTINUATION_BIT) != 0;
      int myDigit = myCharCode & VLQ_BASE_MASK;
      myValue += myDigit << myShift;
      myShift += VLQ_BASE_SHIFT;

      if(!hasContinuation){
        myResult.add(fromVlqSigned(myValue));
        myValue = 0;
        myShift = 0;
      }
    }

    return myResult;
  }

  static int convertingCharToValue(int myCharCode){
    const availableChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    return availableChars.indexOf(String.fromCharCode(myCharCode));
  }
}

//This class loads and parses the map file:
class sourceMapDecoder{
  final String myJsFilePath;

  sourceMapDecoder(this.myJsFilePath);

  Future<Map<String, dynamic>?> decodeTheLocation(int myJsLine, int myJsColumn) async{
    //Loading the .map file that is generated by Flutter:
    final myMapUrl = "${myJsFilePath}.map";

    final myResponse = await http.get(Uri.parse(myMapUrl));

    if(myResponse.statusCode != 200){
      return null;
    }

    final mapJson = jsonDecode(myResponse.body);

    final mySources = List<String>.from(mapJson["sources"]);
    final myMappings = mapJson["mappings"];

    //int myLine = 0;
    //int myColumn = 0;

    int mySourceIndex = 0;
    int mySourceLine = 0;
    int mySourceColumn = 0;

    int myGeneratedLineNum = 0;

    final myLines = myMappings.split(";");

    for(int i = 0; i < myLines.length; i++){
      final mySegments = myLines[i].split(",");

      int myGeneratedColumnNum = 0;

      for(final mySegment in mySegments){
        if(mySegment.trim().isEmpty){
          continue;
        }

        final decoded = myVlqDecoder.decoding(mySegment);

        myGeneratedColumnNum += decoded[0];

        if(i == myJsLine - 1){
          //The correct line has been found:
          mySourceIndex += decoded[1];
          mySourceLine += decoded[2];
          mySourceColumn += decoded[3];

          return { "file_name": mySources[mySourceIndex], "line": mySourceLine + 1, "column": mySourceColumn + 1, };
        }

        //Updating the running totals for other lines:
        if(decoded.length >= 5){
          mySourceIndex += decoded[1];
          mySourceLine += decoded[2];
          mySourceColumn += decoded[3];
        }
      }
      myGeneratedLineNum++;
    }
    return null;
  }
}